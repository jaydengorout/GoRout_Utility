{"version":3,"sources":["helper.es6"],"names":["plain","helper","DataLayerHelper","dataLayer","opt_listener","opt_listenToPast","dataLayer_","listener_","executingListener_","model_","unprocessed_","abstractModelInterface_","buildAbstractModelInterface_","processStates_","oldPush","push","that","states","slice","call","arguments","result","apply","prototype","key","target","split","i","length","undefined","splice","merge_","opt_skipListener","update","shift","isArray_","processCommand_","e","isPlainObject","expandKeyValue_","dataLayerHelper","value","get","command","model","isString_","path","method","pop","args","type","from","to","property","hasOwn","fromProperty"],"mappings":"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","file":"helper.js","sourcesContent":["/** @license Copyright 2012 Google Inc. All rights reserved. */\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Data layer helper library.\n *\n * The dataLayer is a shared queue of objects holding generic information\n * about the page. It uses a standard set of keys so it can be read by anyone\n * that understands the spec (The spec is still under construction). It uses\n * a queue so that the page can record changes to its state. For example, a\n * page might start with the following dataLayer in its head section:\n *\n *   var dataLayer = [{\n *     title: 'Original page title'\n *   }];\n *\n * But in many situations (like an Ajax app), the state/data of the page can\n * change. Using a queue allows the page to update the data when that happens.\n * For example, if the title should change, the page can do this:\n *\n *   dataLayer.push({title: 'New page title'});\n *\n * Strictly speaking, this could have been done without a queue. But using a\n * queue allows readers of the dataLayer to come along at any time and process\n * the entire history of the page's data. This is especially useful for things\n * that load asynchronously or are deferred until long after the page\n * originally loads. But most importantly, using a queue allows all this\n * functionality without requiring a synchronous bootloader script slowing down\n * the page.\n *\n * @author bkuhn@google.com (Brian Kuhn)\n */\n\nimport * as plain from './is_plain_object';\n\nexport var helper = {};\n\n\n/**\n * Creates a new helper object for the given dataLayer.\n *\n * @constructor\n * @param {!Array.<!Object>} dataLayer The dataLayer to help with.\n * @param {function(!Object, !Object)=} opt_listener The callback function to\n *     execute when a new state gets pushed onto the dataLayer.\n * @param {boolean=} opt_listenToPast If true, the given listener will be\n *     executed for state changes that have already happened.\n */\nlet DataLayerHelper = helper.DataLayerHelper = function(dataLayer, opt_listener, opt_listenToPast) {\n\n  /**\n   * The dataLayer to help with.\n   * @type {!Array.<!Object>}\n   * @private\n   */\n  this.dataLayer_ = dataLayer;\n\n  /**\n   * The listener to notify of changes to the dataLayer.\n   * @type {function(!Object, !Object)}\n   * @private\n   */\n  this.listener_ = opt_listener || function() {};\n\n  /**\n   * The internal marker for checking if the listener is currently on the stack.\n   * @type {boolean}\n   * @private\n   */\n  this.executingListener_ = false;\n\n  /**\n   * The internal representation of the dataLayer's state at the time of the\n   * update currently being processed.\n   * @type {!Object}\n   * @private\n   */\n  this.model_ = {};\n\n  /**\n   * The internal queue of dataLayer updates that have not yet been processed.\n   * @type {Array.<Object>}\n   * @private\n   */\n  this.unprocessed_ = [];\n\n  /**\n   * The interface to the internal dataLayer model that is exposed to custom\n   * methods. Custom methods will the executed with this interface as the value\n   * of 'this', allowing users to manipulate the model using this.get and\n   * this.set.\n   * @type {!Object}\n   * @private\n   */\n  this.abstractModelInterface_ = helper.buildAbstractModelInterface_(this);\n\n  // Process the existing/past states.\n  this.processStates_(dataLayer, !opt_listenToPast);\n\n  // Add listener for future state changes.\n  var oldPush = dataLayer.push;\n  var that = this;\n  dataLayer.push = function() {\n    var states = [].slice.call(arguments, 0);\n    var result = oldPush.apply(dataLayer, states);\n    that.processStates_(states);\n    return result;\n  };\n};\n\n/**\n * Returns the value currently assigned to the given key in the helper's\n * internal model.\n *\n * @param {string} key The path of the key to set on the model, where dot (.)\n *     is the path separator.\n * @return {*} The value found at the given key.\n * @this {DataLayerHelper}\n */\nhelper.DataLayerHelper.prototype['get'] = function(key) {\n  var target = this.model_;\n  var split = key.split('.');\n  for (var i = 0; i < split.length; i++) {\n    if (target[split[i]] === undefined) return undefined;\n    target = target[split[i]];\n  }\n  return target;\n};\n\n\n/**\n * Flattens the dataLayer's history into a single object that represents the\n * current state. This is useful for long running apps, where the dataLayer's\n * history may get very large.\n *\n * @this {DataLayerHelper}\n */\nhelper.DataLayerHelper.prototype['flatten'] = function() {\n  this.dataLayer_.splice(0, this.dataLayer_.length);\n  this.dataLayer_[0] = {};\n  helper.merge_(this.model_, this.dataLayer_[0]);\n};\n\n\n/**\n * Merges the given update objects (states) onto the helper's model, calling\n * the listener each time the model is updated. If a command array is pushed\n * into the dataLayer, the method will be parsed and applied to the value found\n * at the key, if a one exists.\n *\n * @param {Array.<Object>} states The update objects to process, each\n *     representing a change to the state of the page.\n * @param {boolean=} opt_skipListener If true, the listener the given states\n *     will be applied to the internal model, but will not cause the listener\n *     to be executed. This is useful for processing past states that the\n *     listener might not care about.\n * @private\n */\nhelper.DataLayerHelper.prototype.processStates_ =\n    function(states, opt_skipListener) {\n\n  this.unprocessed_.push.apply(this.unprocessed_, states);\n  // Checking executingListener here protects against multiple levels of\n  // loops trying to process the same queue. This can happen if the listener\n  // itself is causing new states to be pushed onto the dataLayer.\n  while (this.executingListener_ === false && this.unprocessed_.length > 0) {\n    var update = this.unprocessed_.shift();\n    if (helper.isArray_(update)) {\n      helper.processCommand_(update, this.model_);\n    } else if (typeof update == 'function') {\n      var that = this;\n      try {\n        update.call(this.abstractModelInterface_);\n      } catch (e) {\n        // Catch any exceptions to we don't drop subsequent updates.\n        // TODO: Add some sort of logging when this happens.\n      }\n    } else if (plain.isPlainObject(update)) {\n      for (var key in update) {\n        helper.merge_(helper.expandKeyValue_(key, update[key]), this.model_);\n      }\n    } else {\n      continue;\n    }\n    if (!opt_skipListener) {\n      this.executingListener_ = true;\n      this.listener_(this.model_, update);\n      this.executingListener_ = false;\n    }\n  }\n};\n\n\n/**\n * Helper function that will build the abstract model interface using the\n * supplied dataLayerHelper.\n *\n * @param {DataLayerHelper} dataLayerHelper The helper class to construct the\n *     abstract model interface for.\n * @return {Object} The interface to the abstract data layer model that is given\n *     to Custom Methods.\n * @private\n */\nhelper.buildAbstractModelInterface_ = function(dataLayerHelper) {\n  return {\n    'set': function(key, value) {\n      helper.merge_(helper.expandKeyValue_(key, value),\n          dataLayerHelper.model_);\n    },\n    'get': function(key) {\n      return dataLayerHelper.get(key);\n    }\n  };\n};\n\n\n/**\n * Applies the given method to the value in the dataLayer with the given key.\n * If the method is a valid function of the value, the method will be applies\n * with any arguments passed in.\n *\n * @param {Array.<Object>} command The array containing the key with the\n *     method to execute and optional arguments for the method.\n * @param {Object|Array} model The current dataLayer model.\n * @private\n */\nhelper.processCommand_ = function(command, model) {\n  if (!helper.isString_(command[0])) return;\n  var path = command[0].split('.');\n  var method = path.pop();\n  var args = command.slice(1);\n  var target = model;\n  for (var i = 0; i < path.length; i++) {\n    if (target[path[i]] === undefined) return;\n    target = target[path[i]];\n  }\n  try {\n    target[method].apply(target, args);\n  } catch (e) {\n    // Catch any exception so we don't drop subsequent updates.\n    // TODO: Add some sort of logging here when this happens.\n  }\n};\n\n\n/**\n * Converts the given key value pair into an object that can be merged onto\n * another object. Specifically, this method treats dots in the key as path\n * separators, so the key/value pair:\n *\n *   'a.b.c', 1\n *\n * will become the object:\n *\n *   {a: {b: {c: 1}}}\n *\n * @param {string} key The key's path, where dots are the path separators.\n * @param {*} value The value to set on the given key path.\n * @return {Object} An object representing the given key/value which can be\n *     merged onto the dataLayer's model.\n * @private\n */\nhelper.expandKeyValue_ = function(key, value) {\n  var result = {};\n  var target = result;\n  var split = key.split('.');\n  for (var i = 0; i < split.length - 1; i++) {\n    target = target[split[i]] = {};\n  }\n  target[split[split.length - 1]] = value;\n  return result;\n};\n\n\n/**\n * Determines if the given value is an array.\n *\n * @param {*} value The value to test.\n * @return {boolean} True iff the given value is an array.\n * @private\n */\nhelper.isArray_ = function(value) {\n  return plain.type(value) == 'array';\n};\n\n\n/**\n * Determines if the given value is a string.\n *\n * @param {*} value The value to test.\n * @return {boolean} True iff the given value is a string.\n * @private\n */\nhelper.isString_ = function(value) {\n  return plain.type(value) == 'string';\n};\n\n\n/**\n * Merges one object into another or one array into another. Scalars and\n * \"non-plain\" objects are overwritten when there is a merge conflict.\n * Arrays and \"plain\" objects are merged recursively.\n *\n * TODO(bkuhn): This is just a starting point for how we'll decide which\n * objects get cloned and which get copied. More work is needed to flesh\n * out the details here.\n *\n * @param {Object|Array} from The object or array to merge from.\n * @param {Object|Array} to The object or array to merge into.\n * @private\n */\nhelper.merge_ = function(from, to) {\n  for (var property in from) {\n    if (plain.hasOwn(from, property)) {\n      var fromProperty = from[property];\n      if (helper.isArray_(fromProperty)) {\n        if (!helper.isArray_(to[property])) to[property] = [];\n        helper.merge_(fromProperty, to[property]);\n      } else if (plain.isPlainObject(fromProperty)) {\n        if (!plain.isPlainObject(to[property])) to[property] = {};\n        helper.merge_(fromProperty, to[property]);\n      } else {\n        to[property] = fromProperty;\n      }\n    }\n  }\n};"]}